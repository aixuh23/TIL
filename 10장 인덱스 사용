# 10장 인덱스 사용

## 인덱스와 B-tree

 ■ RDB에서 사용하는 인덱스
  • B-tree 인덱스
      : 데이터를 트리 구조로 저장하는 형태의 인덱스 (가장 많이 사용 why? 균형이 잘 잡혀있기 때문)

    + B-tree VS B+tree
      : 본질적 특징 다르지 않음
        but, B+tree가 검색 기능이 뛰어난 이유는 1) [루트와 리프의 거리를 가능한 일정하게 유지]하려 하기에 균형이 잘 잡혀 검색 성능이 안정적
                                              2) 이분 탐색을 통해 비용 절감


  • 비트맵 인덱스
      : 데이터를 비트 플래그로 변환해서 저장하는 형태의 인덱스
        but, 갱신 시 오버헤드가 큼.

  • 해시 인덱스
      : 키를 분산해서 등가 검색을 고속으로 실행하고자 만들어진 인덱스
        but, 등가 검색 외 효과 거의 없음.



### 인덱스 활용법
 ■ 활용 포인트
    • 카디널리티와 선택률
        what is 카디널리티? It's 값의 균형을 나타내는 개념
        Q. 그렇다면 인덱스는 언제 사용하는게 좋은지 판단하나?
         A. (1) 카디널리티가 높은 것 (2) 선택률이 낮은 것

 ■ 성능 향상 어려운 케이스
    - 압축 조건이 존재하지 않을 때
    - 레코드를 제대로 압축하지 못할 때
    - 인덱스를 사용하지 않는 검색 조건
        -- 중간일치 후방일치 like 조건 || 색인 필드로 연산 || IS NULL 사용하는 경우 


 ■ 인덱스 사용할 수 없는 경우 대처법
    • 외부 설정(UI 설계)로 처리
    • 데이터 마트(=개요 테이블(Summary Table))로 처리
       => 외부 설정 영향을 받지 않는 방법
         * 주의점
        - 데이터 마트 = 원래 테이블의 부분적인 복사본 => 따라서, 특정시점마다 동기화 필요  --> 데이터의 신선도
        - 데이터 마트 만드는 목적 = 테이블 크기를 작게 해 I/O 양 줄이는 것 => 따라서, GROUP BY절을 미리 사용해서 집계 후 사용하며 효과적 --> 데이터 마트 크기
        - 쓸데없이 동기화 일어나면 좀비 마트 생길 가능성 有, 양 늘어나면 저장소 용량 압박 --> 데이터 마트 수
        - 데이터 마트 만드는 데 시간이 걸리기에 배치 윈도우와 JOB NET 고려도 필요 --> 배치 윈도우

    • 인덱스 온리 스캔으로 대처
       => 외부 설정 영향을 받지 않는 방법
        - SQL 구문이 접근하려는 대상의 I/O 감소 목적 (== 데이터 마트 목적)

          ```
           CREATE INDEX CoveringIndex ON Orders(필드명, 필드명);
          ```
             -- 위 필드를 커버하는 인덱스가 존재하면 테이블이 아닌 인덱스만을 스캔 대상으로 하는 검색을 사용할 수 있게 됨. => 커버링 인덱스


※정리※
  - B+tree 인덱스는 편리하지만, 카디널리티와 선택률에 따라 성능이 결정.
  - 선택률을 제어하기 위해서는 UI 설계 변경이 필요.
  - 선택률이 높은 경우에는 인덱스 온리 스캔 활용.
  - 결국 인덱스를 사용한 성능 개선도 I/O 비용을 줄이기 위한 노력임.



[연습문제] Q) 대규모의 테이블에 사용하는 쿼리가 늦어 데이터 마트를 사용해서 성능을 개선하기로 했다고 합시다. 어떤 구현 방법이 있는지 장/단점을 생각해보시오.
          A) Table to Table 갱신: 원본 테이블에서 SELECT 한 결과를 INSERT / UPDATE 하는 방법
             머티리얼라이즈 뷰(Materialized View): DBMS 기능으로 어느 정도 자동화하는 방법




